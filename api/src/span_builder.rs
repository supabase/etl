use actix_web::{
    Error,
    body::MessageBody,
    dev::{ServiceRequest, ServiceResponse},
};
use tracing::{Span, info, warn};
use tracing_actix_web::RootSpanBuilder;

/// The `RootSpanBuilder` implementation for the API service.
///
/// It extracts the project ref from the `tenant_id` header and sets it as a field in the root span.
/// It also emits info logs for request start and completion.
#[derive(Debug)]
pub struct ApiRootSpanBuilder;

impl RootSpanBuilder for ApiRootSpanBuilder {
    fn on_request_start(request: &ServiceRequest) -> Span {
        let project = request.headers().get("tenant_id");
        let span = match project {
            Some(project) => {
                // We convert lossily to a string to be able to read at least part of the project
                // ref in case of invalid UTF-8. This is useful for debugging.
                //
                // However, this is an edge case, as the project ref is generated by the system and
                // should be valid UTF-8.
                let project = String::from_utf8_lossy(project.as_bytes());
                let project = project.as_ref();
                tracing_actix_web::root_span!(request, project = project)
            }
            None => tracing_actix_web::root_span!(request, project = tracing::field::Empty),
        };

        // Log request start within the span
        {
            let _enter = span.enter();
            info!(
                method = %request.method(),
                uri = %request.uri(),
                path = %request.path(),
                query_string = %request.query_string(),
                version = ?request.version(),
                "HTTP request received"
            );
        }

        span
    }

    fn on_request_end<B: MessageBody>(span: Span, outcome: &Result<ServiceResponse<B>, Error>) {
        // Log request completion within the span
        {
            let _enter = span.enter();

            match outcome {
                Ok(response) => {
                    let status_code = response.status().as_u16();
                    let response_size = response
                        .headers()
                        .get("content-length")
                        .and_then(|h| h.to_str().ok())
                        .and_then(|s| s.parse::<u64>().ok())
                        .unwrap_or(0);

                    let response_content_type = response
                        .headers()
                        .get("content-type")
                        .and_then(|h| h.to_str().ok())
                        .unwrap_or("unknown");

                    info!(
                        status_code = status_code,
                        response_size = response_size,
                        response_content_type = %response_content_type,
                        "HTTP request completed successfully"
                    );
                }
                Err(error) => {
                    warn!(
                        error = %error,
                        error_type = %std::any::type_name_of_val(error),
                        "HTTP request completed with error"
                    );
                }
            }
        }
    }
}
