#![cfg(all(feature = "test-utils", feature = "failpoints"))]

use etl::destination::memory::MemoryDestination;
use etl::error::ErrorKind;
use etl::failpoints::{
    SEND_STATUS_UPDATE_FP, START_TABLE_SYNC_BEFORE_DATA_SYNC_SLOT_CREATION_FP,
    START_TABLE_SYNC_DURING_DATA_SYNC_FP,
};
use etl::state::table::{RetryPolicy, TableReplicationPhase, TableReplicationPhaseType};
use etl::test_utils::database::spawn_source_database;
use etl::test_utils::event::group_events_by_type_and_table_id;
use etl::test_utils::notify::NotifyingStore;
use etl::test_utils::pipeline::{create_database_and_pipeline_with_table, create_pipeline};
use etl::test_utils::schema::{
    assert_schema_snapshots_ordering, assert_table_schema_column_names_types,
};
use etl::test_utils::test_destination_wrapper::TestDestinationWrapper;
use etl::test_utils::test_schema::{TableSelection, insert_users_data, setup_test_database_schema};
use etl::types::Type;
use etl::types::{EventType, PipelineId};
use etl_postgres::tokio::test_utils::TableModification;
use etl_telemetry::tracing::init_test_tracing;
use fail::FailScenario;
use rand::random;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::test(flavor = "multi_thread")]
async fn table_copy_fails_after_data_sync_threw_an_error_with_no_retry() {
    let _scenario = FailScenario::setup();
    fail::cfg(
        START_TABLE_SYNC_BEFORE_DATA_SYNC_SLOT_CREATION_FP,
        "1*return(no_retry)",
    )
    .unwrap();

    init_test_tracing();

    let mut database = spawn_source_database().await;
    let database_schema = setup_test_database_schema(&database, TableSelection::UsersOnly).await;

    // Insert initial test data.
    let rows_inserted = 10;
    insert_users_data(
        &mut database,
        &database_schema.users_schema().name,
        1..=rows_inserted,
    )
    .await;

    let store = NotifyingStore::new();
    let destination = TestDestinationWrapper::wrap(MemoryDestination::new());

    // We start the pipeline from scratch.
    let pipeline_id: PipelineId = random();
    let mut pipeline = create_pipeline(
        &database.config,
        pipeline_id,
        database_schema.publication_name(),
        store.clone(),
        destination.clone(),
    );

    // Register notifications for table sync phases.
    let users_state_notify = store
        .notify_on_table_state_type(
            database_schema.users_schema().id,
            TableReplicationPhaseType::Errored,
        )
        .await;

    pipeline.start().await.unwrap();

    users_state_notify.notified().await;

    // We expect to have a no retry error which is generated by the failpoint.
    let err = pipeline.shutdown_and_wait().await.err().unwrap();
    assert_eq!(err.kinds().len(), 1);
    assert_eq!(err.kinds()[0], ErrorKind::WithNoRetry);

    // Verify no data is there.
    let table_rows = destination.get_table_rows().await;
    assert!(table_rows.is_empty());

    // Verify table schemas were correctly stored.
    let table_schemas = store.get_latest_table_schemas().await;
    assert!(table_schemas.is_empty());
}

#[tokio::test(flavor = "multi_thread")]
async fn table_copy_fails_after_timed_retry_exceeded_max_attempts() {
    let _scenario = FailScenario::setup();
    // Since we have table_error_retry_max_attempts: 2, we want to fail 3 times, so that on the 3rd
    // time, the system switches to manual retry.
    fail::cfg(
        START_TABLE_SYNC_BEFORE_DATA_SYNC_SLOT_CREATION_FP,
        "3*return(timed_retry)",
    )
    .unwrap();

    init_test_tracing();

    let mut database = spawn_source_database().await;
    let database_schema = setup_test_database_schema(&database, TableSelection::UsersOnly).await;

    // Insert initial test data.
    let rows_inserted = 10;
    insert_users_data(
        &mut database,
        &database_schema.users_schema().name,
        1..=rows_inserted,
    )
    .await;

    let store = NotifyingStore::new();
    let destination = TestDestinationWrapper::wrap(MemoryDestination::new());

    // We start the pipeline from scratch.
    let pipeline_id: PipelineId = random();
    let mut pipeline = create_pipeline(
        &database.config,
        pipeline_id,
        database_schema.publication_name(),
        store.clone(),
        destination.clone(),
    );

    // Register notifications for waiting on the manual retry which is expected to be flipped by the
    // max attempts handling.
    let users_state_notify = store
        .notify_on_table_state(database_schema.users_schema().id, |phase| {
            matches!(
                phase,
                TableReplicationPhase::Errored {
                    retry_policy: RetryPolicy::ManualRetry,
                    ..
                }
            )
        })
        .await;

    pipeline.start().await.unwrap();

    users_state_notify.notified().await;

    // We expect to still have the timed retry kind since this is the kind of error that we triggered.
    let err = pipeline.shutdown_and_wait().await.err().unwrap();
    assert_eq!(err.kinds().len(), 1);
    assert_eq!(err.kinds()[0], ErrorKind::WithTimedRetry);

    // Verify no data is there.
    let table_rows = destination.get_table_rows().await;
    assert!(table_rows.is_empty());

    // Verify table schemas were correctly stored.
    let table_schemas = store.get_latest_table_schemas().await;
    assert!(table_schemas.is_empty());
}

#[tokio::test(flavor = "multi_thread")]
async fn table_copy_is_consistent_after_data_sync_threw_an_error_with_timed_retry() {
    let _scenario = FailScenario::setup();
    fail::cfg(
        START_TABLE_SYNC_BEFORE_DATA_SYNC_SLOT_CREATION_FP,
        "1*return(timed_retry)",
    )
    .unwrap();

    init_test_tracing();

    let mut database = spawn_source_database().await;
    let database_schema = setup_test_database_schema(&database, TableSelection::UsersOnly).await;

    // Insert initial test data.
    let rows_inserted = 10;
    insert_users_data(
        &mut database,
        &database_schema.users_schema().name,
        1..=rows_inserted,
    )
    .await;

    let store = NotifyingStore::new();
    let destination = TestDestinationWrapper::wrap(MemoryDestination::new());

    // We start the pipeline from scratch.
    let pipeline_id: PipelineId = random();
    let mut pipeline = create_pipeline(
        &database.config,
        pipeline_id,
        database_schema.publication_name(),
        store.clone(),
        destination.clone(),
    );

    // We register the interest in waiting for both table syncs to have started.
    let users_state_notify = store
        .notify_on_table_state_type(
            database_schema.users_schema().id,
            TableReplicationPhaseType::SyncDone,
        )
        .await;

    pipeline.start().await.unwrap();

    users_state_notify.notified().await;

    // We expect no errors, since the same table sync worker task is retried.
    pipeline.shutdown_and_wait().await.unwrap();

    // Verify copied data.
    let table_rows = destination.get_table_rows().await;
    let users_table_rows = table_rows.get(&database_schema.users_schema().id).unwrap();
    assert_eq!(users_table_rows.len(), rows_inserted);

    // Verify table schemas were correctly stored.
    let table_schemas = store.get_latest_table_schemas().await;
    assert_eq!(table_schemas.len(), 1);
    assert_eq!(
        *table_schemas
            .get(&database_schema.users_schema().id)
            .unwrap(),
        database_schema.users_schema()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn table_copy_is_consistent_during_data_sync_threw_an_error_with_timed_retry() {
    let _scenario = FailScenario::setup();
    fail::cfg(
        START_TABLE_SYNC_DURING_DATA_SYNC_FP,
        "1*return(timed_retry)",
    )
    .unwrap();

    init_test_tracing();

    let mut database = spawn_source_database().await;
    let database_schema = setup_test_database_schema(&database, TableSelection::UsersOnly).await;

    // Insert initial test data.
    let rows_inserted = 10;
    insert_users_data(
        &mut database,
        &database_schema.users_schema().name,
        1..=rows_inserted,
    )
    .await;

    let store = NotifyingStore::new();
    let destination = TestDestinationWrapper::wrap(MemoryDestination::new());

    // We start the pipeline from scratch.
    let pipeline_id: PipelineId = random();
    let mut pipeline = create_pipeline(
        &database.config,
        pipeline_id,
        database_schema.publication_name(),
        store.clone(),
        destination.clone(),
    );

    // We register the interest in waiting for both table syncs to have started.
    let users_state_notify = store
        .notify_on_table_state_type(
            database_schema.users_schema().id,
            TableReplicationPhaseType::SyncDone,
        )
        .await;

    pipeline.start().await.unwrap();

    users_state_notify.notified().await;

    // We expect no errors, since the same table sync worker task is retried.
    pipeline.shutdown_and_wait().await.unwrap();

    // Verify copied data.
    let table_rows = destination.get_table_rows().await;
    let users_table_rows = table_rows.get(&database_schema.users_schema().id).unwrap();
    assert_eq!(users_table_rows.len(), rows_inserted);

    // Verify table schemas were correctly stored.
    let table_schemas = store.get_latest_table_schemas().await;
    assert_eq!(table_schemas.len(), 1);
    assert_eq!(
        *table_schemas
            .get(&database_schema.users_schema().id)
            .unwrap(),
        database_schema.users_schema()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn table_schema_snapshots_are_consistent_after_missing_status_update() {
    let _scenario = FailScenario::setup();
    fail::cfg(SEND_STATUS_UPDATE_FP, "return").unwrap();

    init_test_tracing();

    let (database, table_name, table_id, store, destination, pipeline, pipeline_id, publication) =
        create_database_and_pipeline_with_table(
            "schema_add_column",
            &[("name", "text not null"), ("age", "integer not null")],
        )
        .await;

    let notify = destination
        .wait_for_events_count(vec![(EventType::Relation, 2), (EventType::Insert, 2)])
        .await;

    database
        .insert_values(table_name.clone(), &["name", "age"], &[&"Alice", &25])
        .await
        .unwrap();

    database
        .alter_table(
            table_name.clone(),
            &[TableModification::AddColumn {
                name: "email",
                data_type: "text null",
            }],
        )
        .await
        .unwrap();

    database
        .insert_values(
            table_name.clone(),
            &["name", "age", "email"],
            &[&"Bob", &28, &"bob@example.com"],
        )
        .await
        .unwrap();

    notify.notified().await;
    pipeline.shutdown_and_wait().await.unwrap();

    // Assert that we got all the events correctly.
    let events = destination.get_events().await;
    let grouped = group_events_by_type_and_table_id(&events);

    assert_eq!(
        grouped.get(&(EventType::Relation, table_id)).unwrap().len(),
        2
    );
    assert_eq!(
        grouped.get(&(EventType::Insert, table_id)).unwrap().len(),
        2
    );

    // Assert that we have 2 schema snapshots stored in order.
    let table_schemas = store.get_table_schemas().await;
    let table_schemas_snapshots = table_schemas.get(&table_id).unwrap();
    assert_eq!(table_schemas_snapshots.len(), 2);
    assert_schema_snapshots_ordering(table_schemas_snapshots, true);

    // Verify the first snapshot has the original schema (id, name, age).
    let (_, first_schema) = &table_schemas_snapshots[0];
    assert_table_schema_column_names_types(
        first_schema,
        &[
            ("id", Type::INT8),
            ("name", Type::TEXT),
            ("age", Type::INT4),
        ],
    );

    // Verify the second snapshot has the new column added (id, name, age, email).
    let (_, second_schema) = &table_schemas_snapshots[1];
    assert_table_schema_column_names_types(
        second_schema,
        &[
            ("id", Type::INT8),
            ("name", Type::TEXT),
            ("age", Type::INT4),
            ("email", Type::TEXT),
        ],
    );

    // Clear up the state and allow the status update to be sent.
    destination.clear_events().await;
    fail::cfg(SEND_STATUS_UPDATE_FP, "off").unwrap();

    // Restart the pipeline with the failpoint disabled to verify recovery.
    let mut pipeline = create_pipeline(
        &database.config,
        pipeline_id,
        publication,
        store.clone(),
        destination.clone(),
    );

    pipeline.start().await.unwrap();

    database
        .insert_values(
            table_name.clone(),
            &["name", "age", "email"],
            &[&"Charlie", &35, &"charlie@example.com"],
        )
        .await
        .unwrap();

    // TODO: figure out how to wait for errors in the apply worker and remove timeout.
    // We sleep since we don't have a reactive way to listen for errors, which is something that
    // we might want to add.
    sleep(Duration::from_secs(5)).await;

    // We expect to have a corrupted table schema error since when we reprocess the events, Postgres
    // sends a `Relation` message with the `email` column even for entries before the DDL that added
    // the `email`. For now this is a limitation that we are acknowledging, but we would like to find
    // a solution for this.
    let err = pipeline.shutdown_and_wait().await.err().unwrap();
    assert_eq!(err.kinds().len(), 1);
    assert_eq!(err.kinds()[0], ErrorKind::CorruptedTableSchema);
}
