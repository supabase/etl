name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

permissions:
  contents: read

jobs:
  check:
    name: Check
    runs-on: ubuntu-latest
    strategy:
      matrix:
        check: [fmt, clippy]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: ${{ matrix.check == 'fmt' && 'rustfmt' || 'clippy' }}

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.check }}

      - name: Run cargo fmt
        if: matrix.check == 'fmt'
        run: cargo fmt --check

      - name: Run cargo clippy
        if: matrix.check == 'clippy'
        run: cargo clippy --all-targets --all-features --no-deps -- -D warnings

  test:
    name: Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: test

      - name: Start Docker Compose Environment
        run: |
          docker compose -f ./scripts/docker-compose.yaml up -d
          echo "Waiting for lakekeeper, minio, and postgres services to be ready..."

          # Wait for specific services to be healthy
          timeout=300
          elapsed=0
          services="lakekeeper minio postgres"

          while [ $elapsed -lt $timeout ]; do
            all_healthy=true
            for service in $services; do
              health=$(docker compose -f ./scripts/docker-compose.yaml ps --format json | jq -r --arg service "$service" 'select(.Service == $service) | .Health')
              state=$(docker compose -f ./scripts/docker-compose.yaml ps --format json | jq -r --arg service "$service" 'select(.Service == $service) | .State')
              
              if [ "$health" != "healthy" ] || [ "$state" != "running" ]; then
                echo "Service $service is not ready yet (Health: $health, State: $state)"
                all_healthy=false
                break
              fi
            done
            
            if [ "$all_healthy" = true ]; then
              echo "All required services (lakekeeper, minio, postgres) are healthy and running!"
              break
            fi
            
            echo "Waiting for services to be ready... ($elapsed/$timeout seconds)"
            sleep 5
            elapsed=$((elapsed + 5))
          done

          if [ $elapsed -ge $timeout ]; then
            echo "Timeout waiting for services to be ready"
            docker compose -f ./scripts/docker-compose.yaml ps
            exit 1
          fi

      - name: Install sqlx-cli
        run: |
          cargo install sqlx-cli \
            --features native-tls,postgres \
            --no-default-features \
            --locked

      - name: Migrate database
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
          POSTGRES_PORT: 5430
          POSTGRES_HOST: localhost
        run: |
          sudo apt-get install libpq-dev -y
          ./etl-api/scripts/run_migrations.sh

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Set up BigQuery environment variables and credentials
        run: |
          printf '%s' '${{ secrets.TESTS_BIGQUERY_SA_KEY_JSON }}' > /tmp/bigquery-sa-key.json
          echo "TESTS_BIGQUERY_PROJECT_ID=${{ secrets.TESTS_BIGQUERY_PROJECT_ID }}" >> $GITHUB_ENV
          echo "TESTS_BIGQUERY_SA_KEY_PATH=/tmp/bigquery-sa-key.json" >> $GITHUB_ENV

      - name: Generate code coverage
        id: coverage
        run: |
          cargo llvm-cov test \
            --workspace --no-fail-fast \
            --all-features \
            --lcov --output-path lcov.info

      - name: Upload coverage to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          fail-on-error: false
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path-to-lcov: lcov.info
          debug: true
