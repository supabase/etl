name: Docker Build

on:
  workflow_call:
    inputs:
      image:
        description: "Docker image (e.g. public.ecr.aws/supabase/<repo>)"
        type: string
        required: true
      checkout_ref:
        description: "Git ref (branch, SHA, or tag) to check out"
        type: string
        required: false
      file:
        description: "Path to Dockerfile relative to the repository root"
        type: string
        default: "Dockerfile"
      context:
        description: "Docker build context"
        type: string
        default: "."
      push:
        description: "Push image to registry"
        type: boolean
        default: false
      tag_with_version:
        description: "Also tag the image with version"
        type: boolean
        default: false
      version:
        description: "Version to tag when tag_with_version=true"
        type: string
        required: false
      experimental:
        description: "Build experimental image (main branch excluded)"
        type: boolean
        default: false
    secrets:
      PROD_AWS_ROLE:
        description: "AWS IAM role ARN for ECR push access"
        required: true
      SENTRY_AUTH_TOKEN:
        description: "Sentry authentication token for debug symbol upload"
        required: false
      SENTRY_ORG:
        description: "Sentry organization slug"
        required: false
      SENTRY_PROJECT:
        description: "Sentry project slug"
        required: false

permissions:
  contents: read
  actions: write
  id-token: write

jobs:
  # Build each platform natively on its own runner
  build-platform:
    name: Build ${{ matrix.platform }} Image
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: blacksmith-4vcpu-ubuntu-2404
            arch: amd64
          - platform: linux/arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm
            arch: arm64
    outputs:
      digest-amd64: ${{ steps.export-digest.outputs.digest-amd64 }}
      digest-arm64: ${{ steps.export-digest.outputs.digest-arm64 }}
      image-name: ${{ steps.extract-name.outputs.name }}
    steps:
      - name: Extract Image Name
        id: extract-name
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      - name: Check Sentry configuration
        id: sentry-config
        run: |
          if [ -n "$SENTRY_AUTH_TOKEN" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}

      - name: Checkout (specific ref)
        if: inputs.checkout_ref != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_ref }}

      - name: Checkout (default)
        if: inputs.checkout_ref == ''
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        if: inputs.push == true
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        if: inputs.push == true
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      # Build and push the final image first - this caches all intermediate stages
      - name: Build and Push Single-Platform Image
        id: build
        uses: useblacksmith/build-push-action@v2
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.file }}
          push: ${{ inputs.push }}
          platforms: ${{ matrix.platform }}
          provenance: false
          outputs: type=image,name=${{ inputs.image }},push-by-digest=true,name-canonical=true

      # Debug symbol extraction: extract from the stripper stage (same build, cached)
      # The stripper stage has both .debug (unstripped) and stripped binaries
      - name: Extract debug binary from cached build
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        id: extract-debug
        run: |
          BINARY_NAME="${{ steps.extract-name.outputs.name }}"

          # Build to stripper stage - uses cached layers from the main build
          docker build \
            --target stripper \
            --platform ${{ matrix.platform }} \
            -f ${{ inputs.file }} \
            -t ${BINARY_NAME}-stripper \
            ${{ inputs.context }}

          # Create container and extract both binaries
          docker create --name ${BINARY_NAME}-container ${BINARY_NAME}-stripper

          # Extract the unstripped debug binary
          docker cp ${BINARY_NAME}-container:/app/target/release/${BINARY_NAME}.debug ./debug-binary-temp
          if [ -d "./debug-binary-temp" ]; then
            mv "./debug-binary-temp/${BINARY_NAME}.debug" "./${BINARY_NAME}.debug"
            rm -rf ./debug-binary-temp
          else
            mv ./debug-binary-temp "./${BINARY_NAME}.debug"
          fi

          # Extract the stripped binary (to verify Build ID matches)
          docker cp ${BINARY_NAME}-container:/app/target/release/${BINARY_NAME} ./stripped-binary-temp
          if [ -d "./stripped-binary-temp" ]; then
            mv "./stripped-binary-temp/${BINARY_NAME}" "./${BINARY_NAME}.stripped"
            rm -rf ./stripped-binary-temp
          else
            mv ./stripped-binary-temp "./${BINARY_NAME}.stripped"
          fi

          docker rm ${BINARY_NAME}-container

          # Get Build IDs for verification
          DEBUG_BUILD_ID=$(readelf -n "./${BINARY_NAME}.debug" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")
          STRIPPED_BUILD_ID=$(readelf -n "./${BINARY_NAME}.stripped" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")

          echo "=========================================="
          echo "BUILD ID VERIFICATION (${{ matrix.arch }})"
          echo "=========================================="
          echo "Debug binary Build ID:    ${DEBUG_BUILD_ID}"
          echo "Stripped binary Build ID: ${STRIPPED_BUILD_ID}"

          if [ "$DEBUG_BUILD_ID" = "$STRIPPED_BUILD_ID" ]; then
            echo "‚úÖ Build IDs MATCH - debug symbols will work correctly"
          else
            echo "‚ùå Build IDs MISMATCH - debug symbols may not work!"
            echo "This indicates the build was not properly cached."
          fi
          echo "=========================================="

          # Output for later steps
          echo "debug-build-id=${DEBUG_BUILD_ID}" >> "$GITHUB_OUTPUT"
          echo "stripped-build-id=${STRIPPED_BUILD_ID}" >> "$GITHUB_OUTPUT"

          # Cleanup stripped binary, keep debug binary for upload
          rm -f "./${BINARY_NAME}.stripped"

          echo "Debug binary ready for upload:"
          ls -lh "./${BINARY_NAME}.debug"
          file "./${BINARY_NAME}.debug"

      - name: Install debug symbol tools
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y llvm
          curl -sL https://sentry.io/get-cli/ | bash

      - name: Upload debug symbols to Sentry
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        run: |
          BINARY_NAME="${{ steps.extract-name.outputs.name }}"

          echo "=========================================="
          echo "SENTRY DEBUG SYMBOL UPLOAD (${{ matrix.arch }})"
          echo "=========================================="
          echo "Uploading Build ID: ${{ steps.extract-debug.outputs.debug-build-id }}"
          echo "=========================================="

          # Bundle source context
          sentry-cli difutil bundle-sources ./${BINARY_NAME}.debug || true

          # Upload debug symbols to Sentry
          sentry-cli debug-files upload \
            --include-sources \
            ./${BINARY_NAME}.debug

          echo "=========================================="
          echo "‚úÖ Debug symbols uploaded for ${BINARY_NAME} (${{ matrix.arch }})"
          echo "Build ID: ${{ steps.extract-debug.outputs.debug-build-id }}"
          echo "=========================================="

          # Cleanup
          rm -f ./${BINARY_NAME}.debug ./${BINARY_NAME}.debug.src.zip 2>/dev/null || true

      - name: Export Digest
        id: export-digest
        if: inputs.push == true
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          echo "$digest" > "/tmp/digests/${{ matrix.arch }}.txt"
          echo "digest-${{ matrix.arch }}=$digest" >> "$GITHUB_OUTPUT"

      - name: Upload Digest
        if: inputs.push == true
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ steps.extract-name.outputs.name }}-${{ matrix.arch }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Create multi-arch manifest combining both platforms
  create-manifest:
    name: Create Multi-Arch Manifest
    needs: build-platform
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: inputs.push == true
    steps:
      - name: Extract Image Name
        id: extract-name
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      - name: Download Digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ steps.extract-name.outputs.name }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      - name: Checkout (specific ref)
        if: inputs.checkout_ref != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_ref }}

      - name: Checkout (default)
        if: inputs.checkout_ref == ''
        uses: actions/checkout@v4

      - name: Create and Push Multi-Arch Manifest
        run: |
          IMAGE="${{ inputs.image }}"
          FULL_SHA=$(git rev-parse HEAD)

          # Prepare digest list for imagetools
          DIGEST_LIST=""
          for digest_file in /tmp/digests/*.txt; do
            digest=$(cat "$digest_file")
            DIGEST_LIST="${DIGEST_LIST} ${IMAGE}@${digest}"
          done

          if [ "${{ inputs.experimental }}" = "true" ]; then
            # Experimental mode: only tag with commithash-experimental
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}-experimental" ${DIGEST_LIST}
          else
            # Standard mode: tag with latest and SHA
            docker buildx imagetools create -t "${IMAGE}:latest" ${DIGEST_LIST}
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}" ${DIGEST_LIST}

            # Create manifest for version if needed
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              docker buildx imagetools create -t "${IMAGE}:v${{ inputs.version }}" ${DIGEST_LIST}
            fi
          fi

      - name: Output Image Information
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          FULL_SHA=$(git rev-parse HEAD)
          if [ "${{ inputs.experimental }}" = "true" ]; then
            TAGS="${FULL_SHA}-experimental"
            MODE="experimental"
          else
            TAGS="latest, ${FULL_SHA}"
            MODE="standard"
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              TAGS="${TAGS}, v${{ inputs.version }}"
            fi
          fi
          echo "‚úÖ Successfully built and pushed ${NAME} multi-arch image (${MODE} mode)"
          echo "üè∑Ô∏è Tags: ${TAGS}"
          echo "üèóÔ∏è Platforms: linux/amd64, linux/arm64"
          echo "üîó View at: https://gallery.ecr.aws/supabase/${NAME}"
