name: Docker Build

on:
  workflow_call:
    inputs:
      image:
        description: "Docker image (e.g. public.ecr.aws/supabase/<repo>)"
        type: string
        required: true
      checkout_ref:
        description: "Git ref (branch, SHA, or tag) to check out"
        type: string
        required: false
      file:
        description: "Path to Dockerfile relative to the repository root"
        type: string
        default: "Dockerfile"
      context:
        description: "Docker build context"
        type: string
        default: "."
      push:
        description: "Push image to registry"
        type: boolean
        default: false
      tag_with_version:
        description: "Also tag the image with version"
        type: boolean
        default: false
      version:
        description: "Version to tag when tag_with_version=true"
        type: string
        required: false
      experimental:
        description: "Build experimental image (main branch excluded)"
        type: boolean
        default: false
    secrets:
      PROD_AWS_ROLE:
        description: "AWS IAM role ARN for ECR push access"
        required: true
      SENTRY_AUTH_TOKEN:
        description: "Sentry authentication token for debug symbol upload"
        required: false
      SENTRY_ORG:
        description: "Sentry organization slug"
        required: false
      SENTRY_PROJECT:
        description: "Sentry project slug"
        required: false

permissions:
  contents: read
  actions: write
  id-token: write

jobs:
  # Build each platform natively on its own runner
  build-platform:
    name: Build ${{ matrix.platform }} Image
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: blacksmith-4vcpu-ubuntu-2404
            arch: amd64
          - platform: linux/arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm
            arch: arm64
    outputs:
      digest-amd64: ${{ steps.export-digest.outputs.digest-amd64 }}
      digest-arm64: ${{ steps.export-digest.outputs.digest-arm64 }}
      image-name: ${{ steps.extract-name.outputs.name }}
    steps:
      - name: Extract Image Name
        id: extract-name
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      - name: Check Sentry configuration
        id: sentry-config
        run: |
          if [ -n "$SENTRY_AUTH_TOKEN" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}

      - name: Checkout (specific ref)
        if: inputs.checkout_ref != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_ref }}

      - name: Checkout (default)
        if: inputs.checkout_ref == ''
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        if: inputs.push == true
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        if: inputs.push == true
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      # Build stripper stage FIRST and extract debug symbols
      # This caches all the heavy compilation work (chef -> planner -> builder -> stripper)
      # The final image build will then only need to add the thin final layer
      - name: Build stripper stage and extract debug binary
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        id: extract-debug
        run: |
          set -euo pipefail
          BINARY_NAME="${{ steps.extract-name.outputs.name }}"

          echo "Building to stripper stage (caches all compilation)..."

          # Build to stripper stage and export filesystem
          # This does the heavy lifting and caches all layers
          mkdir -p ./build-output
          docker buildx build \
            --target stripper \
            --platform ${{ matrix.platform }} \
            --output type=local,dest=./build-output \
            -f ${{ inputs.file }} \
            ${{ inputs.context }}

          # Move binaries to working directory
          mv ./build-output/app/target/release/${BINARY_NAME}.debug ./${BINARY_NAME}.debug
          mv ./build-output/app/target/release/${BINARY_NAME} ./${BINARY_NAME}.stripped
          rm -rf ./build-output

          # Get Build IDs for verification
          DEBUG_BUILD_ID=$(readelf -n "./${BINARY_NAME}.debug" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")
          STRIPPED_BUILD_ID=$(readelf -n "./${BINARY_NAME}.stripped" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")

          echo "=========================================="
          echo "BUILD ID VERIFICATION (${{ matrix.arch }})"
          echo "=========================================="
          echo "Debug binary Build ID:    ${DEBUG_BUILD_ID}"
          echo "Stripped binary Build ID: ${STRIPPED_BUILD_ID}"

          if [ "$DEBUG_BUILD_ID" = "$STRIPPED_BUILD_ID" ]; then
            echo "‚úÖ Build IDs MATCH - debug symbols will work correctly"
          else
            echo "‚ùå Build IDs MISMATCH - debug symbols will not work!"
            echo "This indicates the build was not properly cached."
            exit 1
          fi
          echo "=========================================="

          # Output for later steps
          echo "debug-build-id=${DEBUG_BUILD_ID}" >> "$GITHUB_OUTPUT"

          # Show file sizes for context
          echo ""
          echo "File sizes:"
          echo "  Debug (unstripped): $(du -h ./${BINARY_NAME}.debug | cut -f1)"
          echo "  Stripped:           $(du -h ./${BINARY_NAME}.stripped | cut -f1)"

          # Cleanup stripped binary, keep debug binary for upload
          rm -f "./${BINARY_NAME}.stripped"

      - name: Install sentry-cli
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        run: curl -sL https://sentry.io/get-cli/ | bash

      - name: Upload debug symbols to Sentry
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        run: |
          set -euo pipefail
          BINARY_NAME="${{ steps.extract-name.outputs.name }}"

          echo "=========================================="
          echo "SENTRY DEBUG SYMBOL UPLOAD (${{ matrix.arch }})"
          echo "=========================================="
          echo "Build ID: ${{ steps.extract-debug.outputs.debug-build-id }}"
          echo "File size: $(du -h ./${BINARY_NAME}.debug | cut -f1)"
          echo "=========================================="

          # Validate debug file before upload
          echo "Validating debug file..."
          sentry-cli debug-files check ./${BINARY_NAME}.debug

          # Bundle source context (optional, continue if fails)
          if ! sentry-cli difutil bundle-sources ./${BINARY_NAME}.debug; then
            echo "‚ö†Ô∏è Source bundling failed (non-fatal), continuing with upload..."
          fi

          # Upload debug symbols to Sentry
          sentry-cli debug-files upload \
            --include-sources \
            ./${BINARY_NAME}.debug

          echo "=========================================="
          echo "‚úÖ Debug symbols uploaded for ${BINARY_NAME} (${{ matrix.arch }})"
          echo "=========================================="

          # Cleanup
          rm -f ./${BINARY_NAME}.debug ./${BINARY_NAME}.debug.src.zip 2>/dev/null || true

      # Build and push final image - uses cached stripper stage, only adds thin final layer
      - name: Build and Push Single-Platform Image
        id: build
        uses: useblacksmith/build-push-action@v2
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.file }}
          push: ${{ inputs.push }}
          platforms: ${{ matrix.platform }}
          provenance: false
          outputs: type=image,name=${{ inputs.image }},push-by-digest=true,name-canonical=true

      - name: Export Digest
        id: export-digest
        if: inputs.push == true
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          echo "$digest" > "/tmp/digests/${{ matrix.arch }}.txt"
          echo "digest-${{ matrix.arch }}=$digest" >> "$GITHUB_OUTPUT"

      - name: Upload Digest
        if: inputs.push == true
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ steps.extract-name.outputs.name }}-${{ matrix.arch }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Create multi-arch manifest combining both platforms
  create-manifest:
    name: Create Multi-Arch Manifest
    needs: build-platform
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: inputs.push == true
    steps:
      - name: Extract Image Name
        id: extract-name
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      - name: Download Digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ steps.extract-name.outputs.name }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      - name: Checkout (specific ref)
        if: inputs.checkout_ref != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_ref }}

      - name: Checkout (default)
        if: inputs.checkout_ref == ''
        uses: actions/checkout@v4

      - name: Create and Push Multi-Arch Manifest
        run: |
          IMAGE="${{ inputs.image }}"
          FULL_SHA=$(git rev-parse HEAD)

          # Prepare digest list for imagetools
          DIGEST_LIST=""
          for digest_file in /tmp/digests/*.txt; do
            digest=$(cat "$digest_file")
            DIGEST_LIST="${DIGEST_LIST} ${IMAGE}@${digest}"
          done

          if [ "${{ inputs.experimental }}" = "true" ]; then
            # Experimental mode: only tag with commithash-experimental
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}-experimental" ${DIGEST_LIST}
          else
            # Standard mode: tag with latest and SHA
            docker buildx imagetools create -t "${IMAGE}:latest" ${DIGEST_LIST}
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}" ${DIGEST_LIST}

            # Create manifest for version if needed
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              docker buildx imagetools create -t "${IMAGE}:v${{ inputs.version }}" ${DIGEST_LIST}
            fi
          fi

      - name: Output Image Information
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          FULL_SHA=$(git rev-parse HEAD)
          if [ "${{ inputs.experimental }}" = "true" ]; then
            TAGS="${FULL_SHA}-experimental"
            MODE="experimental"
          else
            TAGS="latest, ${FULL_SHA}"
            MODE="standard"
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              TAGS="${TAGS}, v${{ inputs.version }}"
            fi
          fi
          echo "‚úÖ Successfully built and pushed ${NAME} multi-arch image (${MODE} mode)"
          echo "üè∑Ô∏è Tags: ${TAGS}"
          echo "üèóÔ∏è Platforms: linux/amd64, linux/arm64"
          echo "üîó View at: https://gallery.ecr.aws/supabase/${NAME}"
