name: Docker Build

on:
  workflow_call:
    inputs:
      image:
        description: "Docker image (e.g. public.ecr.aws/supabase/<repo>)"
        type: string
        required: true
      checkout_ref:
        description: "Git ref (branch, SHA, or tag) to check out"
        type: string
        required: false
      file:
        description: "Path to Dockerfile relative to the repository root"
        type: string
        default: "Dockerfile"
      context:
        description: "Docker build context"
        type: string
        default: "."
      push:
        description: "Push image to registry"
        type: boolean
        default: false
      tag_with_version:
        description: "Also tag the image with version"
        type: boolean
        default: false
      version:
        description: "Version to tag when tag_with_version=true"
        type: string
        required: false
      experimental:
        description: "Build experimental image (main branch excluded)"
        type: boolean
        default: false
      binary_name:
        description: "Name of the binary (defaults to image repo name if not specified)"
        type: string
        required: false
    secrets:
      PROD_AWS_ROLE:
        description: "AWS IAM role ARN for ECR push access"
        required: true
      SENTRY_AUTH_TOKEN:
        description: "Sentry authentication token for debug symbol upload"
        required: false
      SENTRY_ORG:
        description: "Sentry organization slug"
        required: false
      SENTRY_PROJECT:
        description: "Sentry project slug"
        required: false

env:
  # Pin sentry-cli version for reproducibility
  SENTRY_CLI_VERSION: "3.0.1"

permissions:
  contents: read
  actions: write
  id-token: write

jobs:
  # Build each platform natively on its own runner
  build-platform:
    name: Build ${{ matrix.platform }} Image
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: blacksmith-4vcpu-ubuntu-2404
            arch: amd64
          - platform: linux/arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm
            arch: arm64
    outputs:
      digest-amd64: ${{ steps.export-digest.outputs.digest-amd64 }}
      digest-arm64: ${{ steps.export-digest.outputs.digest-arm64 }}
      image-name: ${{ steps.extract-name.outputs.image-name }}
      binary-name: ${{ steps.extract-name.outputs.binary-name }}
      git-sha: ${{ steps.git-sha.outputs.sha }}
    steps:
      - name: Extract Image and Binary Name
        id: extract-name
        run: |
          IMAGE="${{ inputs.image }}"
          IMAGE_NAME="${IMAGE##*/}"
          echo "image-name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

          # Use explicit binary_name if provided, otherwise default to image name
          if [ -n "${{ inputs.binary_name }}" ]; then
            BINARY_NAME="${{ inputs.binary_name }}"
          else
            BINARY_NAME="$IMAGE_NAME"
          fi
          echo "binary-name=$BINARY_NAME" >> "$GITHUB_OUTPUT"
          echo "Image: $IMAGE_NAME, Binary: $BINARY_NAME"

      - name: Check Sentry configuration
        id: sentry-config
        run: |
          # Require all three Sentry variables to be set
          if [ -n "$SENTRY_AUTH_TOKEN" ] && [ -n "$SENTRY_ORG" ] && [ -n "$SENTRY_PROJECT" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            echo "Sentry debug symbol upload: enabled"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "Sentry debug symbol upload: disabled (missing SENTRY_AUTH_TOKEN, SENTRY_ORG, or SENTRY_PROJECT)"
          fi
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}

      - name: Checkout (specific ref)
        if: inputs.checkout_ref != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_ref }}

      - name: Checkout (default)
        if: inputs.checkout_ref == ''
        uses: actions/checkout@v4

      - name: Get Git SHA
        id: git-sha
        run: |
          SHA=$(git rev-parse HEAD)
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "Git SHA: $SHA"

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        if: inputs.push == true
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        if: inputs.push == true
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      # Build debug-symbols stage FIRST and extract debug symbols
      # This caches all the heavy compilation work (chef -> planner -> builder -> stripper)
      # The debug-symbols stage is a minimal scratch image with only the binaries we need
      # The final image build will then only need to add the thin final layer
      - name: Build and extract debug symbols
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        id: extract-debug
        run: |
          set -euo pipefail
          BINARY_NAME="${{ steps.extract-name.outputs.binary-name }}"
          CACHE_SCOPE="${{ steps.extract-name.outputs.image-name }}-${{ matrix.arch }}"

          echo "Building to debug-symbols stage (caches all compilation)..."

          # Build to debug-symbols stage and export only those files
          # The debug-symbols stage is FROM scratch with only the 2 binaries (~100MB)
          # Uses GHA cache backend for cross-run caching
          mkdir -p ./debug-output
          docker buildx build \
            --target debug-symbols \
            --platform ${{ matrix.platform }} \
            --cache-from type=gha,scope=$CACHE_SCOPE \
            --cache-to type=gha,scope=$CACHE_SCOPE,mode=max \
            --output type=local,dest=./debug-output \
            -f ${{ inputs.file }} \
            ${{ inputs.context }}

          # Move binaries to working directory
          mv ./debug-output/${BINARY_NAME}.debug ./${BINARY_NAME}.debug
          mv ./debug-output/${BINARY_NAME} ./${BINARY_NAME}.stripped
          rm -rf ./debug-output

          # Get Build IDs for verification
          DEBUG_BUILD_ID=$(readelf -n "./${BINARY_NAME}.debug" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")
          STRIPPED_BUILD_ID=$(readelf -n "./${BINARY_NAME}.stripped" 2>/dev/null | grep "Build ID" | awk '{print $3}' || echo "unknown")

          echo "=========================================="
          echo "BUILD ID VERIFICATION (${{ matrix.arch }})"
          echo "=========================================="
          echo "Debug binary Build ID:    ${DEBUG_BUILD_ID}"
          echo "Stripped binary Build ID: ${STRIPPED_BUILD_ID}"

          if [ "$DEBUG_BUILD_ID" = "$STRIPPED_BUILD_ID" ]; then
            echo "‚úÖ Build IDs MATCH - debug symbols will work correctly"
          else
            echo "‚ùå Build IDs MISMATCH - debug symbols will not work!"
            echo "This indicates the build was not properly cached."
            exit 1
          fi
          echo "=========================================="

          # Output for later steps
          echo "debug-build-id=${DEBUG_BUILD_ID}" >> "$GITHUB_OUTPUT"

          # Show file sizes for context
          echo ""
          echo "File sizes:"
          echo "  Debug symbols: $(du -h ./${BINARY_NAME}.debug | cut -f1)"
          echo "  Stripped:      $(du -h ./${BINARY_NAME}.stripped | cut -f1)"

          # Prepare debug files directory for Sentry upload
          # Sentry recommends uploading from a directory, not a single file
          # Include both stripped binary and debug companion for best matching
          mkdir -p ./sentry-dif/${{ matrix.arch }}
          mv ./${BINARY_NAME}.debug ./sentry-dif/${{ matrix.arch }}/
          mv ./${BINARY_NAME}.stripped ./sentry-dif/${{ matrix.arch }}/${BINARY_NAME}

      - name: Install sentry-cli
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        run: |
          # Determine architecture for sentry-cli download
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            SENTRY_ARCH="aarch64"
          else
            SENTRY_ARCH="x86_64"
          fi
          curl -sL "https://release-registry.services.sentry.io/apps/sentry-cli/${SENTRY_CLI_VERSION}?response=download&arch=${SENTRY_ARCH}&platform=Linux&package=sentry-cli" -o /tmp/sentry-cli
          chmod +x /tmp/sentry-cli
          sudo mv /tmp/sentry-cli /usr/local/bin/sentry-cli
          sentry-cli --version

      - name: Upload debug symbols to Sentry
        if: inputs.push == true && steps.sentry-config.outputs.enabled == 'true'
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        run: |
          set -euo pipefail
          BINARY_NAME="${{ steps.extract-name.outputs.binary-name }}"

          echo "=========================================="
          echo "SENTRY DEBUG SYMBOL UPLOAD (${{ matrix.arch }})"
          echo "=========================================="
          echo "Build ID: ${{ steps.extract-debug.outputs.debug-build-id }}"
          echo "=========================================="

          # Validate both files before upload
          echo "Validating debug files..."
          sentry-cli difutil check ./sentry-dif/${{ matrix.arch }}/${BINARY_NAME}
          sentry-cli difutil check ./sentry-dif/${{ matrix.arch }}/${BINARY_NAME}.debug

          # Upload debug symbols to Sentry from directory (includes both stripped binary and debug companion)
          echo "Uploading debug symbols..."
          sentry-cli debug-files upload \
            --include-sources \
            --wait \
            ./sentry-dif/${{ matrix.arch }}/

          echo "=========================================="
          echo "‚úÖ Debug symbols uploaded for ${BINARY_NAME} (${{ matrix.arch }})"
          echo "=========================================="

          # Cleanup
          rm -rf ./sentry-dif

      # Build and push final image - uses cached stripper stage, only adds thin final layer
      - name: Build and Push Single-Platform Image
        id: build
        uses: useblacksmith/build-push-action@v2
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.file }}
          push: ${{ inputs.push }}
          platforms: ${{ matrix.platform }}
          provenance: false
          outputs: type=image,name=${{ inputs.image }},push-by-digest=true,name-canonical=true
          cache-from: type=gha,scope=${{ steps.extract-name.outputs.image-name }}-${{ matrix.arch }}
          cache-to: type=gha,scope=${{ steps.extract-name.outputs.image-name }}-${{ matrix.arch }},mode=max

      - name: Export Digest
        id: export-digest
        if: inputs.push == true
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          echo "$digest" > "/tmp/digests/${{ matrix.arch }}.txt"
          echo "digest-${{ matrix.arch }}=$digest" >> "$GITHUB_OUTPUT"

      - name: Upload Digest
        if: inputs.push == true
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ steps.extract-name.outputs.image-name }}-${{ matrix.arch }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  # Create multi-arch manifest combining both platforms
  create-manifest:
    name: Create Multi-Arch Manifest
    needs: build-platform
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: inputs.push == true
    steps:
      - name: Download Digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ needs.build-platform.outputs.image-name }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: useblacksmith/setup-docker-builder@v1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR Public
        uses: docker/login-action@v3
        with:
          registry: public.ecr.aws

      - name: Create and Push Multi-Arch Manifest
        run: |
          IMAGE="${{ inputs.image }}"
          # Use the exact SHA from the build job, not from a fresh checkout
          FULL_SHA="${{ needs.build-platform.outputs.git-sha }}"

          echo "Using Git SHA from build job: $FULL_SHA"

          # Prepare digest list for imagetools
          DIGEST_LIST=""
          for digest_file in /tmp/digests/*.txt; do
            digest=$(cat "$digest_file")
            DIGEST_LIST="${DIGEST_LIST} ${IMAGE}@${digest}"
          done

          if [ "${{ inputs.experimental }}" = "true" ]; then
            # Experimental mode: only tag with commithash-experimental
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}-experimental" ${DIGEST_LIST}
          else
            # Standard mode: tag with latest and SHA
            docker buildx imagetools create -t "${IMAGE}:latest" ${DIGEST_LIST}
            docker buildx imagetools create -t "${IMAGE}:${FULL_SHA}" ${DIGEST_LIST}

            # Create manifest for version if needed
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              docker buildx imagetools create -t "${IMAGE}:v${{ inputs.version }}" ${DIGEST_LIST}
            fi
          fi

      - name: Output Image Information
        run: |
          IMAGE="${{ inputs.image }}"
          NAME="${IMAGE##*/}"
          FULL_SHA="${{ needs.build-platform.outputs.git-sha }}"
          if [ "${{ inputs.experimental }}" = "true" ]; then
            TAGS="${FULL_SHA}-experimental"
            MODE="experimental"
          else
            TAGS="latest, ${FULL_SHA}"
            MODE="standard"
            if [ "${{ inputs.tag_with_version }}" = "true" ] && [ -n "${{ inputs.version }}" ]; then
              TAGS="${TAGS}, v${{ inputs.version }}"
            fi
          fi
          echo "‚úÖ Successfully built and pushed ${NAME} multi-arch image (${MODE} mode)"
          echo "üè∑Ô∏è Tags: ${TAGS}"
          echo "üèóÔ∏è Platforms: linux/amd64, linux/arm64"
          echo "üîó View at: https://gallery.ecr.aws/supabase/${NAME}"
